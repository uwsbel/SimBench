```python
import pychrono as chrono
import pychrono.postprocess as postprocess

# Create a Chrono system
system = chrono.ChSystemNSC()

# Set gravitational acceleration
system.Set_G_acc(chrono.ChVectorD(0, -9.81, 0))

# Create a floor
floor_material = chrono.ChMaterialSurfaceNSC()
floor_body = chrono.ChRigidBodyShared()
floor_body.SetBodyFixed(True)
floor_body.SetCollide(True)
floor_body.GetCollisionModel().ClearModel()
floor_body.GetCollisionModel().AddBox(5, 0.1, 5)
floor_body.GetCollisionModel().BuildModel()
floor_body.SetMaterialSurface(floor_material)
system.Add(floor_body)

# No other objects or instructions were provided, so we'll add a simple sphere
sphere_material = chrono.ChMaterialSurfaceNSC()
sphere_body = chrono.ChRigidBodyShared()
sphere_body.SetMass(1)
sphere_body.SetInertiaXX(chrono.ChVectorD(0.4, 0.4, 0.4))
sphere_body.SetPos(chrono.ChVectorD(0, 1, 0))
sphere_body.SetCollide(True)
sphere_body.GetCollisionModel().ClearModel()
sphere_body.GetCollisionModel().AddSphere(0.5)  # radius = 0.5
sphere_body.GetCollisionModel().BuildModel()
sphere_body.SetMaterialSurface(sphere_material)
system.Add(sphere_body)


# Simulation parameters
time_step = 0.01
total_time = 5

# Create a POV-Ray output
pov_exporter = postprocess.ChPovRay(system)

# Set some file parameters
pov_exporter.SetTemplateFile("../../data/template_POV.pov")
pov_exporter.SetOutputScriptFile("rendering_frames.pov")
pov_exporter.SetOutputDataFilebase("my_state")
pov_exporter.SetPictureFilebase("picture")

# Make the animation and output some PovRay files
pov_exporter.SetCamera(chrono.ChVectorD(8, 4, 10), chrono.ChVectorD(0, 0, 0),
                     chrono.ChVectorD(0, 1, 0))
pov_exporter.SetLight(chrono.ChVectorD(-2, 5, 7), chrono.ChColor(1.2, 1.2, 1.2))
pov_exporter.SetPictureSize(600, 400)
pov_exporter.SetAmbientLight(chrono.ChColor(0.8, 0.8, 0.8))

pov_exporter.AddAll()
pov_exporter.ExportScript()

# Perform the simulation
while system.GetChTime() < total_time:
    system.DoStepDynamics(time_step)

    # Output POV-Ray data
    pov_exporter.ExportData()
```

**Explanation:**

1. **Initialization:**
    - `import pychrono as chrono`: Imports the PyChrono library.
    - `import pychrono.postprocess as postprocess`: Imports the post-processing module for visualization.
    - `system = chrono.ChSystemNSC()`: Creates a Chrono system using the NSC (Non-Smooth Contacts) solver.

2. **Floor Creation:**
    - A static floor is created using a `ChRigidBodyShared` object with collision enabled.
    - A box shape is added to its collision model.
    - `floor_body.SetBodyFixed(True)` makes the floor immobile.

3. **Sphere Creation (Default Object):**
    - Since no specific object was requested, a simple sphere is added to the scene.
    - It's given a mass, inertia, initial position, and a spherical collision shape.

4. **Simulation Parameters:**
    - `time_step` and `total_time` define the simulation's time resolution and duration.

5. **POV-Ray Visualization (Optional):**
    - This section sets up POV-Ray rendering to visualize the simulation.
    - You can comment this out if you don't need visualization.

6. **Simulation Loop:**
    - `while system.GetChTime() < total_time:`: The main simulation loop.
    - `system.DoStepDynamics(time_step)`: Advances the simulation by one time step.
    - `pov_exporter.ExportData()`: Exports data for POV-Ray rendering (if enabled).

**Key Concepts:**

- **ChSystemNSC:** The core simulation environment.
- **ChRigidBodyShared:** Represents rigid bodies in the simulation.
- **Collision Shapes:** Define the geometry of objects for collision detection.
- **Material Properties:** Control the interaction between objects during contact.
- **Time Integration:** `DoStepDynamics` advances the simulation based on physics laws.

**To run this script:**

1. Make sure you have PyChrono installed.
2. Save the code as a Python file (e.g., `simulation.py`).
3. Run it from the command line: `python simulation.py`

This will create a basic simulation of a sphere falling onto a floor. You can modify the parameters and add more objects as needed based on your specific requirements. Remember to adjust the POV-Ray settings if you want to visualize the simulation.

```python
import pychrono.core as chrono
import pychrono.irrlicht as irr
import pychrono.vehicle as veh
import math

chrono.SetChronoDataPath(chrono.GetChronoDataPath())
veh.SetDataPath(chrono.GetChronoDataPath() + 'vehicle/')

# Initial vehicle location and orientation
# Changed initial position to (-15, 0, 0.5)
initLoc = chrono.ChVector3d(-15, 0, 0.5)
# Adjusted initial rotation for the new starting position
initRot = chrono.ChQuaterniond(1, 0, 0, 0) 

# Visualization type for vehicle parts (PRIMITIVES, MESH, or NONE)
vis_type = veh.VisualizationType_MESH

# Collision type for chassis (PRIMITIVES, MESH, or NONE)
chassis_collision_type = veh.CollisionType_NONE

# Type of tire model (RIGID, TMEASY)
tire_model = veh.TireModelType_TMEASY

# Rigid terrain
# terrain_model = veh.RigidTerrain.BOX
terrainHeight = 0      # terrain height
terrainLength = 200.0  # size in X direction (increased for lane change)
terrainWidth = 100.0   # size in Y direction

# Poon chassis tracked by the camera
# Updated track point to (3, 0, 2.1)
trackPoint = chrono.ChVector3d(3, 0, 2.1) 

# Contact method
contact_method = chrono.ChContactMethod_NSC
contact_vis = False

# Simulation step sizes
step_size = 1e-3
tire_step_size = step_size

# Time interval between two render frames
render_step_size = 1.0 / 50  # FPS = 50

# Create the kraz vehicle, set parameters, and initialize

vehicle = veh.Kraz()
vehicle.SetContactMethod(contact_method)
vehicle.SetChassisCollisionType(chassis_collision_type)
vehicle.SetChassisFixed(False)
vehicle.SetInitPosition(chrono.ChCoordsysd(initLoc, initRot))
vehicle.Initialize()

vehicle.SetChassisVisualizationType(vis_type, vis_type)
vehicle.SetSteeringVisualizationType(vis_type)
vehicle.SetSuspensionVisualizationType(vis_type, vis_type)
vehicle.SetWheelVisualizationType(vis_type, vis_type)
vehicle.SetTireVisualizationType(vis_type, vis_type)

vehicle.GetSystem().SetCollisionSystemType(chrono.ChCollisionSystem.Type_BULLET)

# Create the terrain
patch_mat = chrono.ChContactMaterialNSC()
patch_mat.SetFriction(0.9)
patch_mat.SetRestitution(0.01)
terrain = veh.RigidTerrain(vehicle.GetSystem())
patch = terrain.AddPatch(patch_mat, 
    chrono.ChCoordsysd(chrono.ChVector3d(0, 0, 0), chrono.QUNIT), 
    terrainLength, terrainWidth)

patch.SetTexture(veh.GetDataFile("terrain/textures/tile4.jpg"), 200, 200)
patch.SetColor(chrono.ChColor(0.8, 0.8, 0.5))
terrain.Initialize()

# Create the vehicle Irrlicht interface
vis = veh.ChWheeledVehicleVisualSystemIrrlicht()
vis.SetWindowTitle('Kraz Demo')
vis.SetWindowSize(1280, 1024)
# Adjusted chase camera distance to 25.0, 10.5
vis.SetChaseCamera(trackPoint, 25.0, 10.5) 
vis.Initialize()
vis.AddLogo(chrono.GetChronoDataFile('logo_pychrono_alpha.png'))
vis.AddLightDirectional()
vis.AddSkyBox()
vis.AttachVehicle(vehicle.GetTractor())


# Create the driver system
driver = veh.ChInteractiveDriverIRR(vis)

# Set the time response for steering and throttle keyboard inputs.
steering_time = 1.0  # time to go from 0 to +1 (or from 0 to -1)
throttle_time = 1.0  # time to go from 0 to +1
braking_time = 0.3   # time to go from 0 to +1
driver.SetSteeringDelta(render_step_size / steering_time)
driver.SetThrottleDelta(render_step_size / throttle_time)
driver.SetBrakingDelta(render_step_size / braking_time)

driver.Initialize()

# output vehicle mass
print( "VEHICLE MASS: ",  vehicle.GetTractor().GetMass())

# Number of simulation steps between miscellaneous events
render_steps = math.ceil(render_step_size / step_size)

# Initialize simulation frame counter s
realtime_timer = chrono.ChRealtimeStepTimer()
step_number = 0
render_frame = 0

while vis.Run() :
    time = vehicle.GetSystem().GetChTime()

    # Double Lane Change Maneuver
    if 5 < time < 6:
        driver.SetSteering(0.5)  # Steer to the right
        driver.SetThrottle(0.6)
    elif 6 < time < 7:
        driver.SetSteering(-0.5) # Steer to the left
        driver.SetThrottle(0.6)
    elif 7 < time < 8:
        driver.SetSteering(0.5)  # Steer back to the right
        driver.SetThrottle(0.6) 
    else:
        driver.SetSteering(0)
        driver.SetThrottle(0.4)

    # Render scene and output POV-Ray data
    if (step_number % render_steps == 0) :
        vis.BeginScene()
        vis.Render()
        vis.EndScene()
        render_frame += 1

    # Get driver inputs
    driver_inputs = driver.GetInputs()

    # Update modules (process inputs from other modules)
    driver.Synchronize(time)
    terrain.Synchronize(time)
    vehicle.Synchronize(time, driver_inputs, terrain)
    vis.Synchronize(time, driver_inputs)

    # Advance simulation for one timestep for all modules
    driver.Advance(step_size)
    terrain.Advance(step_size)
    vehicle.Advance(step_size)
    vis.Advance(step_size)

    # Increment frame number
    step_number += 1

    # Spin in place for real time to catch up
    realtime_timer.Spin(step_size)

```

**Explanation of Changes:**

1. **Initial Position and Rotation:**
   - The initial position of the vehicle is changed to `(-15, 0, 0.5)`. 
   - The initial rotation is kept at `(1, 0, 0, 0)`, which represents no rotation and should be suitable for the new starting position. 

2. **Camera Track Point and Distance:**
   - The `trackPoint` is updated to `(3, 0, 2.1)`, placing the camera slightly ahead of the vehicle's new starting point.
   - The `SetChaseCamera` parameters are modified to `(trackPoint, 25.0, 10.5)`, adjusting the camera's height for a better view of the lane change maneuver.

3. **Double Lane Change Maneuver:**
   - Within the simulation loop, a time-based sequence is introduced to control the vehicle's steering and throttle for the lane change maneuver.
   - The vehicle performs the following actions:
     - Between 5 and 6 seconds: Steers to the right.
     - Between 6 and 7 seconds: Steers to the left.
     - Between 7 and 8 seconds: Steers back to the right.
   - Outside of this time frame, the steering angle is set to 0, and the throttle is set to a constant value for straight driving.

4. **Terrain Size:**
   - The `terrainLength` is increased to `200.0` to accommodate the lane change maneuver. This ensures the vehicle has enough space to complete the maneuver without going off the terrain.

These changes implement the requested modifications and should result in a simulation where the vehicle starts at the new location, the camera follows from an adjusted viewpoint, and the vehicle performs a double lane change maneuver during the simulation.

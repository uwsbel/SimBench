```python
import pychrono as chrono
import pychrono.sensor as sens

# ---------------------------------------------------------------------
#
#  Create the simulation system and add items
#

# Create a Chrono system
system = chrono.ChSystemNSC()

# Set gravitational acceleration
system.Set_G_acc(chrono.ChVectorD(0, 0, 0))

# Create a mesh from the .obj file
mesh = chrono.ChTriangleMeshConnected()
mesh.LoadWavefrontMesh("your_mesh.obj")  # Replace with your .obj file path

# Create a body based on the mesh
mesh_body = chrono.ChBodyEasyMesh(
    mesh,  # Mesh to use
    1000,  # Density
    True,  # Compute mass and inertia
    True,  # Create visualization asset
    True,  # Enable contact
)
mesh_body.SetBodyFixed(True)  # Fix the mesh in space
system.Add(mesh_body)

# ---------------------------------------------------------------------
#
#  Create a sensor manager and add a lidar sensor
#

manager = sens.ChSensorManager(system)

# Set the update rate of the sensor manager
manager.SetUpdateRate(50)

# Create a lidar sensor
lidar = sens.ChLidarSensor(
    mesh_body,  # Body to attach the sensor to
    sens.ChFrameD(chrono.ChVectorD(0, 0, 0)),  # Position relative to the body
    360,  # Horizontal samples
    1,  # Vertical samples
    chrono.CH_C_DEG_TO_RAD * 120,  # Horizontal field of view
    chrono.CH_C_DEG_TO_RAD * 1,  # Vertical field of view
    100.0,  # Maximum distance
)

# Set noise model for the lidar
# lidar.SetNoiseModel(sens.ChNoiseNone())
lidar.SetNoiseModel(sens.ChNoiseNormal(0.01, 0.001))  # Example: Gaussian noise

# Set visualization mode for the lidar
lidar.SetVisualizationType(sens.VisualizationType_POINT_CLOUD)

# Enable data output
lidar.EnableDataRecording(True)

# Add the lidar sensor to the sensor manager
manager.AddSensor(lidar)

# ---------------------------------------------------------------------
#
#  Simulation loop
#

# Simulation parameters
time_step = 0.01
time_end = 10

# Orbit parameters
orbit_radius = 5
orbit_speed = 1

# Simulation loop
time = 0.0
while time < time_end:
    # Update lidar position in orbit
    orbit_angle = orbit_speed * time
    lidar_x = orbit_radius * chrono.ChCos(orbit_angle)
    lidar_y = orbit_radius * chrono.ChSin(orbit_angle)
    lidar.SetOffsetPose(chrono.ChFrameD(chrono.ChVectorD(lidar_x, lidar_y, 0)))

    # Advance the simulation
    manager.Update()
    system.DoStepDynamics(time_step)
    time += time_step

    # Print lidar buffer data
    print("Time:", time)
    points = lidar.GetMostRecentBuffer()
    for point in points:
        print(point)

# Save lidar data to file
lidar.ExportData("lidar_data.csv")
```

**Explanation:**

1. **Initialization:** The script starts by importing necessary libraries, creating a Chrono system (`system`), and setting the gravitational acceleration.
2. **Mesh Loading and Body Creation:** A triangular mesh is loaded from a specified .obj file using `ChTriangleMeshConnected`. A rigid body (`mesh_body`) is then created from the mesh and added to the system as a fixed object.
3. **Sensor Manager and Lidar Setup:** A sensor manager (`manager`) is created to manage the lidar sensor. A `ChLidarSensor` object is created and attached to the `mesh_body`. The lidar's properties, such as the number of horizontal and vertical samples, field of view, maximum distance, noise model, and visualization type, are configured. Data recording is enabled for the lidar sensor.
4. **Simulation Loop:** The simulation loop iterates over time, dynamically updating the lidar's position in an orbit around the mesh. At each step, the sensor manager is updated, the simulation is advanced, and the lidar buffer data (point cloud) is printed.
5. **Data Export:** After the simulation, the lidar data is saved to a CSV file named "lidar_data.csv".

**Remember to:**

* Replace `"your_mesh.obj"` with the actual path to your .obj file.
* Adjust the simulation parameters (e.g., `time_step`, `time_end`, `orbit_radius`, `orbit_speed`) as needed.
* Explore different noise models and visualization options provided by the `pychrono.sensor` module.

This script provides a basic framework for simulating a lidar sensor orbiting a static mesh. You can further customize it by adding more objects, changing the environment, or implementing more complex sensor configurations.
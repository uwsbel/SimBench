[
    {
        "instruction": "\n    \n    You are a PyChrono expert tasked with generating a simulation script based on the following instructions and a given PyChrono script, which may contain errors. Your task has two parts: identify the potential errors in the script and correct them if exist, also follow the instructions to modify the script to meet the requirements.\n\nHere is the PyChrono code you need to modify:\n\u201c\u201d\"\nimport pychrono as chrono\nimport pychrono.irrlicht as chronoirr\nfrom itertools import combinations\n\nclass MyCreatorForAll(chrono.ChRandomShapeCreator_AddBodyCallback):\n    def __init__(self, vis, coll):\n        super().__init__()\n        self.vis = vis\n        self.coll = coll\n\n    def OnAddBody(self, body, coords, creator):\n        body.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile(\"textures/bluewhite.png\"))\n        self.vis.BindItem(body)\n        self.coll.BindItem(body)\n        body.SetUseGyroTorque(False)\n\n# Create a Chrono physical system\nsys = chrono.ChSystemNSC()\nsys.SetCollisionSystemType(chrono.ChCollisionSystem.Type_BULLET)\ncoll = sys.GetCollisionSystem()\n\n# Create a sphere body\nsphere_mat = chrono.ChContactMaterialNSC()\nsphere_mat.SetFriction(0.2)\nmsphereBody = chrono.ChBodyEasySphere(2.1, 1800, True, True, sphere_mat)\nmsphereBody.SetPos(chrono.ChVector3d(1, 1, 0))\nmsphereBody.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile(\"textures/concrete.jpg\"))\nsys.Add(msphereBody)\n\n# Create an emitter\nemitter = chrono.ChParticleEmitter()\nemitter.SetParticlesPerSecond(2000)\nemitter.SetUseParticleReservoir(True)\nemitter.SetParticleReservoirAmount(200)\n\n# Randomizers for particle properties\nemitter_positions = chrono.ChRandomParticlePositionOnGeometry()\nemitter_positions.SetGeometry(chrono.ChBox(50, 50, 50), chrono.ChFramed())\nemitter.SetParticlePositioner(emitter_positions)\n\nemitter_rotations = chrono.ChRandomParticleAlignmentUniform()\nemitter.SetParticleAligner(emitter_rotations)\n\nmvelo = chrono.ChRandomParticleVelocityAnyDirection()\nmvelo.SetModulusDistribution(chrono.ChUniformDistribution(0.0, 0.5))\nemitter.SetParticleVelocity(mvelo)\n\nmangvelo = chrono.ChRandomParticleVelocityAnyDirection()\nmangvelo.SetModulusDistribution(chrono.ChUniformDistribution(0.0, 0.2))\nemitter.SetParticleAngularVelocity(mangvelo)\n\nmcreator_spheres = chrono.ChRandomShapeCreatorSpheres()\nmcreator_spheres.SetDiameterDistribution(chrono.ChZhangDistribution(0.6, 0.23))\nmcreator_spheres.SetDensityDistribution(chrono.ChConstantDistribution(1600))\nemitter.SetParticleCreator(mcreator_spheres)\n\n# Create the Irrlicht visualization\nvis = chronoirr.ChVisualSystemIrrlicht()\nvis.AttachSystem(sys)\nvis.SetWindowSize(1024, 768)\nvis.SetWindowTitle('Particle emitter demo')\nvis.Initialize()\nvis.AddLogo(chrono.GetChronoDataFile('logo_pychrono_alpha.png'))\nvis.AddSkyBox()\nvis.AddCamera(chrono.ChVector3d(0, 14, -20))\nvis.AddTypicalLights()\n\nmcreation_callback = MyCreatorForAll(vis, coll)\nemitter.RegisterAddBodyCallback(mcreation_callback)\n\nsys.SetSolverType(chrono.ChSolver.Type_PSOR)\nsys.GetSolver().AsIterative().SetMaxIterations(40)\nsys.SetGravitationalAcceleration(chrono.ChVector3d(0, 0, 0))\n\n# Simulation loop\nstepsize = 1e-2\n\nwhile vis.Run():\n    vis.BeginScene()\n    vis.Render()\n    vis.EndScene()\n\n    emitter.EmitParticles(sys, stepsize)\n\n    for body in sys.GetBodies():\n        body.EmptyAccumulators()\n\n    G_constant = 6.674e-3  # Modified gravitational constant\n\n    # Calculate the total kinetic energy of the system\n    kinetic_energy = 0\n    for body in sys.GetBodies():\n        mass = body.GetMass()\n        velocity = body.GetPosDt()\n        kinetic_energy += 0.5 * mass * velocity.Length2()\n\n    # Calculate the total potential energy of the system (using gravitational potential)\n    potential_energy = 0\n    for abodyA, abodyB in combinations(sys.GetBodies(), 2):\n        D_attract = abodyB.GetPos() - abodyA.GetPos()\n        r_attract = D_attract.Length()\n        potential_energy += -G_constant * (abodyA.GetMass() * abodyB.GetMass()) / r_attract\n\n    # Total energy of the system\n    total_energy = kinetic_energy + potential_energy\n    mlist = list(combinations(sys.GetBodies(), 2))\n    for abodyA, abodyB in mlist:\n        D_attract = abodyB.GetPos() - abodyA.GetPos()\n        r_attract = D_attract.Length()\n        f_attract = G_constant * (abodyA.GetMass() * abodyB.GetMass()) / (r_attract ** 2)\n        F_attract = (D_attract / r_attract) * f_attract\n        abodyA.AccumulateForce(F_attract, abodyA.GetPos(), False)\n        abodyB.AccumulateForce(-F_attract, abodyB.GetPos(), False)\n\n    # Print the energy values\n    print(\n        f\"Kinetic Energy: {kinetic_energy:.6f}, Potential Energy: {potential_energy:.6f}, Total Energy: {total_energy:.6f}\")\n\n    sys.DoStepDynamics(stepsize)\n\n\n\u201c\u201d\"\n\nPlease modify the given code based on the following instructions:\n\u201c\u201d\"\n1. **Add Two Additional Spheres for a Three-Body Simulation**:\n   - Introduce two more `ChBodyEasySphere` objects to create a three-body problem.\n   - Set initial positions for the new spheres:\n     - Sphere 2: Position at `(-10, -10, 0)`.\n     - Sphere 3: Position at `(0, 20, 0)`.\n   - Configure initial velocities to simulate dynamic interactions:\n     - Sphere 1: Velocity of `(0.5, 0, 0.1)`.\n     - Sphere 2: Velocity of `(-0.5, 0, -0.1)`.\n     - Sphere 3: Velocity of `(0, -0.5, 0.2)`.\n\n\u201c\u201d\"\n\nTo complete the task, follow these steps:\n\nReview the given PyChrono script and identify any errors, including syntax errors, logical errors, incorrect method names, and parameter issues.\nCorrect the identified errors in the script to ensure it runs correctly.\nModify the script based on the provided instructions to ensure it meets the specified requirements.\n\nProvide the corrected and modified script below:\n    ",
        "input": "",
        "output": "import pychrono as chrono\nimport pychrono.irrlicht as chronoirr\nfrom itertools import combinations\n\nclass MyCreatorForAll(chrono.ChRandomShapeCreator_AddBodyCallback):\n    def __init__(self, vis, coll):\n        super().__init__()\n        self.vis = vis\n        self.coll = coll\n\n    def OnAddBody(self, body, coords, creator):\n        body.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile(\"textures/bluewhite.png\"))\n        self.vis.BindItem(body)\n        self.coll.BindItem(body)\n        body.SetUseGyroTorque(False)\n\n# Create a Chrono physical system\nsys = chrono.ChSystemNSC()\nsys.SetCollisionSystemType(chrono.ChCollisionSystem.Type_BULLET)\ncoll = sys.GetCollisionSystem()\n\n# Create a sphere body\nsphere_mat = chrono.ChContactMaterialNSC()\nsphere_mat.SetFriction(0.2)\nmsphereBody = chrono.ChBodyEasySphere(2.1, 1800, True, True, sphere_mat)\nmsphereBody.SetPos(chrono.ChVector3d(1, 1, 0))\nmsphereBody.SetVel(chrono.ChVectorD(0.5, 0, 0.1))\nmsphereBody.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile(\"textures/concrete.jpg\"))\nsys.Add(msphereBody)\n\n# Create two more spheres\nsphere_mat2 = chrono.ChContactMaterialNSC()\nsphere_mat2.SetFriction(0.2)\nmsphereBody2 = chrono.ChBodyEasySphere(2.1, 1800, True, True, sphere_mat2)\nmsphereBody2.SetPos(chrono.ChVector3d(-10, -10, 0))\nmsphereBody2.SetVel(chrono.ChVectorD(-0.5, 0, -0.1))\nsys.Add(msphereBody2)\n\nsphere_mat3 = chrono.ChContactMaterialNSC()\nsphere_mat3.SetFriction(0.2)\nmsphereBody3 = chrono.ChBodyEasySphere(2.1, 1800, True, True, sphere_mat3)\nmsphereBody3.SetPos(chrono.ChVector3d(0, 20, 0))\nmsphereBody3.SetVel(chrono.ChVectorD(0, -0.5, 0.2))\nsys.Add(msphereBody3)\n\n# Create an emitter\nemitter = chrono.ChParticleEmitter()\nemitter.SetParticlesPerSecond(2000)\nemitter.SetUseParticleReservoir(True)\nemitter.SetParticleReservoirAmount(200)\n\n# Randomizers for particle properties\nemitter_positions = chrono.ChRandomParticlePositionOnGeometry()\nemitter_positions.SetGeometry(chrono.ChBox(50, 50, 50), chrono.ChFramed())\nemitter.SetParticlePositioner(emitter_positions)\n\nemitter_rotations = chrono.ChRandomParticleAlignmentUniform()\nemitter.SetParticleAligner(emitter_rotations)\n\nmvelo = chrono.ChRandomParticleVelocityAnyDirection()\nmvelo.SetModulusDistribution(chrono.ChUniformDistribution(0.0, 0.5))\nemitter.SetParticleVelocity(mvelo)\n\nmangvelo = chrono.ChRandomParticleVelocityAnyDirection()\nmangvelo.SetModulusDistribution(chrono.ChUniformDistribution(0.0, 0.2))\nemitter.SetParticleAngularVelocity(mangvelo)\n\nmcreator_spheres = chrono.ChRandomShapeCreatorSpheres()\nmcreator_spheres.SetDiameterDistribution(chrono.ChZhangDistribution(0.6, 0.23))\nmcreator_spheres.SetDensityDistribution(chrono.ChConstantDistribution(1600))\nemitter.SetParticleCreator(mcreator_spheres)\n\n# Create the Irrlicht visualization\nvis = chronoirr.ChVisualSystemIrrlicht()\nvis.AttachSystem(sys)\nvis.SetWindowSize(1024, 768)\nvis.SetWindowTitle('Particle emitter demo')\nvis.Initialize()\nvis.AddLogo(chrono.GetChronoDataFile('logo_pychrono_alpha.png'))\nvis.AddSkyBox()\nvis.AddCamera(chrono.ChVector3d(0, 14, -20))\nvis.AddTypicalLights()\n\nmcreation_callback = MyCreatorForAll(vis, coll)\nemitter.RegisterAddBodyCallback(mcreation_callback)\n\nsys.SetSolverType(chrono.ChSolver.Type_PSOR)\nsys.GetSolver().AsIterative().SetMaxIterations(40)\nsys.SetGravitationalAcceleration(chrono.ChVector3d(0, 0, 0))\n\n# Simulation loop\nstepsize = 1e-2\n\nwhile vis.Run():\n    vis.BeginScene()\n    vis.Render()\n    vis.EndScene()\n\n    emitter.EmitParticles(sys, stepsize)\n\n    for body in sys.GetBodies():\n        body.EmptyAccumulators()\n\n    G_constant = 6.674e-3  # Modified gravitational constant\n\n    # Calculate the total kinetic energy of the system\n    kinetic_energy = 0\n    for body in sys.GetBodies():\n        mass = body.GetMass()\n        velocity = body.GetPosDt()\n        kinetic_energy += 0.5 * mass * velocity.Length2()\n\n    # Calculate the total potential energy of the system (using gravitational potential)\n    potential_energy = 0\n    for abodyA, abodyB in combinations(sys.GetBodies(), 2):\n        D_attract = abodyB.GetPos() - abodyA.GetPos()\n        r_attract = D_attract.Length()\n        potential_energy += -G_constant * (abodyA.GetMass() * abodyB.GetMass()) / r_attract\n\n    # Total energy of the system\n    total_energy = kinetic_energy + potential_energy\n    mlist = list(combinations(sys.GetBodies(), 2))\n    for abodyA, abodyB in mlist:\n        D_attract = abodyB.GetPos() - abodyA.GetPos()\n        r_attract = D_attract.Length()\n        f_attract = G_constant * (abodyA.GetMass() * abodyB.GetMass()) / (r_attract ** 2)\n        F_attract = (D_attract / r_attract) * f_attract\n        abodyA.AccumulateForce(F_attract, abodyA.GetPos(), False)\n        abodyB.AccumulateForce(-F_attract, abodyB.GetPos(), False)\n\n    # Print the energy values\n    print(\n        f\"Kinetic Energy: {kinetic_energy:.6f}, Potential Energy: {potential_energy:.6f}, Total Energy: {total_energy:.6f}\")\n\n    sys.DoStepDynamics(stepsize)",
        "system": "You are a PyChrono expert tasked with generating a simulation script based on the following instructions.",
        "history": [
            [
                "\n    You are a PyChrono expert tasked with generating a simulation script based on the following instructions. Make sure to:\n    1. Initialize the PyChrono environment and core components.\n    2. Add the required physical systems and objects as specified.\n    3. Set necessary default parameters such as positions, forces, and interactions.\n\n    Instructions:\n    \u201c\u201d\"\n    Create a PyChrono simulation that models the gravitational attraction between particles. Implement a particle emitter to generate particles with random shapes, positions, velocities, and orientations. Visualize the simulation using Irrlicht, applying custom gravitational forces to simulate particle attraction dynamically.\n    \u201c\u201d\"\n    ",
                "To create the requested PyChrono simulation, follow the steps below to generate a Python script that meets the specified requirements.\n\n```python\n# Import necessary PyChrono modules\nfrom pychrono import *\nfrom pychrono.irrlicht import *\nfrom pychrono.particles import *\nfrom pychrono.fea import *\nimport irrlicht\nimport random\n\n# Set random seed for reproducibility\nrandom.seed(0)\n\n# Initialize the PyChrono environment and Irrlicht visualization\nmy_system = ChronoSystem()\nmy_visualization = IrrlichtVisualization(my_system, \"Particle Attraction Simulation\")\n\n# Set up the gravitational force\ngravity = Vector3D(0.0, -9.81, 0.0)\nmy_system.AddForce Law2(gravity, my_system.GetChronoData().Get_system_time())\n\n# Create a particle emitter\nemitter = ParticleEmitter(my_system)\nemitter.SetParticleRadius(0.1)\nemitter.SetParticleMass(1.0)\n\n# Generate particles with random shapes, positions, velocities, and orientations\nnum_particles = 50\nfor i in range(num_particles):\n    # Create a random particle shape\n    shape_type = random.choice([\"SPHERE\", \"BOX\", \"CYLINDER\"])\n    if shape_type == \"SPHERE\":\n        particle = Particle(my_system, ChVectorD(0, 0, 0), 1.0, ChVectorD(0, 0, 0))\n    elif shape_type == \"BOX\":\n        particle = Particle(my_system, ChVectorD(0, 0, 0), 1.0, ChVectorD(0, 0, 0))\n        particle.SetBoxShape(ChVectorD(0.2, 0.2, 0.2))\n    elif shape_type == \"CYLINDER\":\n        particle = Particle(my_system, ChVectorD(0, 0, 0), 1.0, ChVectorD(0, 0, 0))\n        particle.SetCylinderShape(0.1, 0.2)\n\n    # Set random position, velocity, and orientation\n    pos = ChVectorD(random.uniform(-5, 5), random.uniform(-5, 5), random.uniform(-5, 5))\n    vel = ChVectorD(random.uniform(-1, 1), random.uniform(-1, 1), random.uniform(-1, 1))\n    particle.SetPos(pos)\n    particle.SetVel(vel)\n    particle.SetWvel(ChVectorD(0, 0, 0))\n\n    # Add the particle to the emitter\n    emitter.AddParticle(particle)\n\n# Set up custom gravitational forces for particle attraction\nfor i in range(num_particles):\n    for j in range(i + 1, num_particles):\n        dist = emitter.GetParticle(i).GetPos() - emitter.GetParticle(j).GetPos()\n        force_mag = 100.0 / dist.Length()\n        force = dist.Normalize() * force_mag\n        my_system.AddForce(Law2(force, my_system.GetChronoData().Get_system_time()), emitter.GetParticle(i))\n        my_system.AddForce(Law2(-force, my_system.GetChronoData().Get_system_time()), emitter.GetParticle(j))\n\n# Run the simulation\nmy_system.Set_delta_time(1e-3)\nsim_time = 10.0\nwhile my_system.GetChronoData().Get_system_time() < sim_time:\n    my_system.DoStepDynamics()\n    my_visualization.Run()\n\n# Clean up and close the visualization\nmy_visualization.Wait()\nmy_visualization.Close()\n```\n\nThis script initializes the PyChrono environment, creates a particle emitter, and adds particles with random shapes, positions, velocities, and orientations. It also sets up custom gravitational forces for particle attraction and visualizes the simulation using Irrlicht."
            ],
            [
                "\n    \n    You are a PyChrono expert tasked with generating a simulation script based on the following instructions and a given PyChrono script, which may contain errors. Your task has two parts: identify the potential errors in the script and correct them if exist, also follow the instructions to modify the script to meet the requirements.\n\nHere is the PyChrono code you need to modify:\n\u201c\u201d\"\nimport pychrono as chrono\nimport pychrono.irrlicht as chronoirr\nfrom itertools import combinations\n\n\nclass MyCreatorForAll(chrono.ChRandomShapeCreator_AddBodyCallback):\n    def __init__(self, vis, coll):\n        super().__init__()\n        self.vis = vis\n        self.coll = coll\n\n    def OnAddBody(self, body, coords, creator):\n        body.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile(\"textures/bluewhite.png\"))\n        self.vis.BindItem(body)\n        self.coll.BindItem(body)\n        body.SetUseGyroTorque(False)\n\n\n# Create a Chrono physical system\nsys = chrono.ChSystemNSC()\nsys.SetCollisionSystemType(chrono.ChCollisionSystem.Type_BULLET)\ncoll = sys.GetCollisionSystem()\n\n# Create a sphere body\nsphere_mat = chrono.ChContactMaterialNSC()\nsphere_mat.SetFriction(0.2)\nmsphereBody = chrono.ChBodyEasySphere(2.1, 1800, True, True, sphere_mat)\nmsphereBody.SetPos(chrono.ChVector3d(1, 1, 0))\nmsphereBody.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile(\"textures/concrete.jpg\"))\nsys.Add(msphereBody)\n\n# Create a particle emitter\nemitter = chrono.ChParticleEmitter()\nemitter.SetParticlesPerSecond(2000)\nemitter.SetUseParticleReservoir(True)\nemitter.SetParticleReservoirAmount(200)\n\n# Randomizers for particle properties\nemitter_positions = chrono.ChRandomParticlePositionOnGeometry()\nemitter_positions.SetGeometry(chrono.ChBox(50, 50, 50), chrono.ChFramed())\nemitter.SetParticlePositioner(emitter_positions)\n\nemitter_rotations = chrono.ChRandomParticleAlignmentUniform()\nemitter.SetParticleAligner(emitter_rotations)\n\nmvelo = chrono.ChRandomParticleVelocityAnyDirection()\nmvelo.SetModulusDistribution(chrono.ChUniformDistribution(0.0, 0.5))\nemitter.SetParticleVelocity(mvelo)\n\nmangvelo = chrono.ChRandomParticleVelocityAnyDirection()\nmangvelo.SetModulusDistribution(chrono.ChUniformDistribution(0.0, 0.2))\nemitter.SetParticleAngularVelocity(mangvelo)\n\nmcreator_hulls = chrono.ChRandomShapeCreatorConvexHulls()\nmcreator_hulls.SetNpoints(15)\nmcreator_hulls.SetChordDistribution(chrono.ChZhangDistribution(1.3, 0.4))\nmcreator_hulls.SetDensityDistribution(chrono.ChConstantDistribution(1600))\nemitter.SetParticleCreator(mcreator_hulls)\n\n# Create the Irrlicht visualization\nvis = chronoirr.ChVisualSystemIrrlicht()\nvis.AttachSystem(sys)\nvis.SetWindowSize(1024, 768)\nvis.SetWindowTitle('Particle emitter demo')\nvis.Initialize()\nvis.AddLogo(chrono.GetChronoDataFile('logo_pychrono_alpha.png'))\nvis.AddSkyBox()\nvis.AddCamera(chrono.ChVector3d(0, 14, -20))\nvis.AddTypicalLights()\n\n# Attach callback to the emitter\nmcreation_callback = MyCreatorForAll(vis, coll)\nemitter.RegisterAddBodyCallback(mcreation_callback)\n\n# Simulation settings\nsys.SetSolverType(chrono.ChSolver.Type_PSOR)\nsys.GetSolver().AsIterative().SetMaxIterations(40)\nsys.SetGravitationalAcceleration(chrono.ChVector3d(0, 0, 0))\n\n# Simulation loop\nstepsize = 1e-2\nG_constant = 6.674e-3  # Modified gravitational constant\n\nwhile vis.Run():\n    vis.BeginScene()\n    vis.Render()\n    vis.EndScene()\n\n    emitter.EmitParticles(sys, stepsize)\n\n    for body in sys.GetBodies():\n        body.EmptyAccumulators()\n\n    mlist = list(combinations(sys.GetBodies(), 2))\n    for abodyA, abodyB in mlist:\n        D_attract = abodyB.GetPos() - abodyA.GetPos()\n        r_attract = D_attract.Length()\n        f_attract = G_constant * (abodyA.GetMass() * abodyB.GetMass()) / (r_attract ** 2)\n        F_attract = (D_attract / r_attract) * f_attract\n        abodyA.AccumulateForce(F_attract, abodyA.GetPos(), False)\n        abodyB.AccumulateForce(-F_attract, abodyB.GetPos(), False)\n\n    sys.DoStepDynamics(stepsize)\n\n\u201c\u201d\"\n\nPlease modify the given code based on the following instructions:\n\u201c\u201d\"\n1. **Replace the Particle Creator**:\n   - Change the particle shape creator from `chrono.ChRandomShapeCreatorConvexHulls` to `chrono.ChRandomShapeCreatorSpheres`.\n   - Configure the new `mcreator_spheres` with appropriate diameter and density distributions:\n     - Set the diameter distribution using `chrono.ChZhangDistribution` with parameters `0.6` and `0.23`.\n     - Set the density distribution using `chrono.ChConstantDistribution` with a value of `1600`.\n\n2. **Add Energy Calculations**:\n   - Add variables to calculate the kinetic and potential energy of the system during each simulation step.\n   - Compute the kinetic energy by iterating over all bodies, summing up `0.5 * mass * velocity.Length2()` for each body.\n   - Compute the gravitational potential energy between each pair of bodies in combinations, summing up `-G_constant * (mass_A * mass_B) / r_attract` for each pair.\n   - Sum these values to get the total energy and print the kinetic, potential, and total energy values in each simulation step.\n\n3. **Adjust Position of `G_constant`**:\n   - Move the definition of `G_constant` inside the simulation loop just before the energy calculations for better organization.\n\u201c\u201d\"\n\nTo complete the task, follow these steps:\n\nReview the given PyChrono script and identify any errors, including syntax errors, logical errors, incorrect method names, and parameter issues.\nCorrect the identified errors in the script to ensure it runs correctly.\nModify the script based on the provided instructions to ensure it meets the specified requirements.\n\nProvide the corrected and modified script below:\n    ",
                "import pychrono as chrono\nimport pychrono.irrlicht as chronoirr\nfrom itertools import combinations\n\nclass MyCreatorForAll(chrono.ChRandomShapeCreator_AddBodyCallback):\n    def __init__(self, vis, coll):\n        super().__init__()\n        self.vis = vis\n        self.coll = coll\n\n    def OnAddBody(self, body, coords, creator):\n        body.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile(\"textures/bluewhite.png\"))\n        self.vis.BindItem(body)\n        self.coll.BindItem(body)\n        body.SetUseGyroTorque(False)\n\n# Create a Chrono physical system\nsys = chrono.ChSystemNSC()\nsys.SetCollisionSystemType(chrono.ChCollisionSystem.Type_BULLET)\ncoll = sys.GetCollisionSystem()\n\n# Create a sphere body\nsphere_mat = chrono.ChContactMaterialNSC()\nsphere_mat.SetFriction(0.2)\nmsphereBody = chrono.ChBodyEasySphere(2.1, 1800, True, True, sphere_mat)\nmsphereBody.SetPos(chrono.ChVector3d(1, 1, 0))\nmsphereBody.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile(\"textures/concrete.jpg\"))\nsys.Add(msphereBody)\n\n# Create a particle emitter\nemitter = chrono.ChParticleEmitter()\nemitter.SetParticlesPerSecond(2000)\nemitter.SetUseParticleReservoir(True)\nemitter.SetParticleReservoirAmount(200)\n\n# Randomizers for particle properties\nemitter_positions = chrono.ChRandomParticlePositionOnGeometry()\nemitter_positions.SetGeometry(chrono.ChBox(50, 50, 50), chrono.ChFramed())\nemitter.SetParticlePositioner(emitter_positions)\n\nemitter_rotations = chrono.ChRandomParticleAlignmentUniform()\nemitter.SetParticleAligner(emitter_rotations)\n\nmvelo = chrono.ChRandomParticleVelocityAnyDirection()\nmvelo.SetModulusDistribution(chrono.ChUniformDistribution(0.0, 0.5))\nemitter.SetParticleVelocity(mvelo)\n\nmangvelo = chrono.ChRandomParticleVelocityAnyDirection()\nmangvelo.SetModulusDistribution(chrono.ChUniformDistribution(0.0, 0.2))\nemitter.SetParticleAngularVelocity(mangvelo)\n\nmcreator_spheres = chrono.ChRandomShapeCreatorSpheres()\nmcreator_spheres.SetDiameterDistribution(chrono.ChZhangDistribution(0.6, 0.23))\nmcreator_spheres.SetDensityDistribution(chrono.ChConstantDistribution(1600))\nemitter.SetParticleCreator(mcreator_spheres)\n\n# Create the Irrlicht visualization\nvis = chronoirr.ChVisualSystemIrrlicht()\nvis.AttachSystem(sys)\nvis.SetWindowSize(1024, 768)\nvis.SetWindowTitle('Particle emitter demo')\nvis.Initialize()\nvis.AddLogo(chrono.GetChronoDataFile('logo_pychrono_alpha.png'))\nvis.AddSkyBox()\nvis.AddCamera(chrono.ChVector3d(0, 14, -20))\nvis.AddTypicalLights()\n\n# Attach callback to the emitter\nmcreation_callback = MyCreatorForAll(vis, coll)\nemitter.RegisterAddBodyCallback(mcreation_callback)\n\n# Simulation settings\nsys.SetSolverType(chrono.ChSolver.Type_PSOR)\nsys.GetSolver().AsIterative().SetMaxIterations(40)\nsys.SetGravitationalAcceleration(chrono.ChVector3d(0, 0, 0))\n\nG_constant = 6.674e-3  # Gravitational constant\n\n# Simulation loop\nstepsize = 1e-2\n\nwhile vis.Run():\n    vis.BeginScene()\n    vis.Render()\n    vis.EndScene()\n\n    emitter.EmitParticles(sys, stepsize)\n\n    total_kinetic_energy = 0\n    total_potential_energy = 0\n\n    for body in sys.GetBodies():\n        total_kinetic_energy += 0.5 * body.GetMass() * body.GetPos_dt().Length2()\n\n    mlist = list(combinations(sys.GetBodies(), 2))\n    for abodyA, abodyB in mlist:\n        D_attract = abodyB.GetPos() - abodyA.GetPos()\n        r_attract = D_attract.Length()\n        f_attract = G_constant * (abodyA.GetMass() * abodyB.GetMass()) / (r_attract ** 2)\n        F_attract = (D_attract / r_attract) * f_attract\n        abodyA.AccumulateForce(F_attract, abodyA.GetPos(), False)\n        abodyB.AccumulateForce(-F_attract, abodyB.GetPos(), False)\n        total_potential_energy += -G_constant * (abodyA.GetMass() * abodyB.GetMass()) / r_attract\n\n    total_energy = total_kinetic_energy + total_potential_energy\n\n    print(\"Kinetic Energy: \", total_kinetic_energy)\n    print(\"Potential Energy: \", total_potential_energy)\n    print(\"Total Energy: \", total_energy, \"\\n\")\n\n    for body in sys.GetBodies():\n        body.EmptyAccumulators()\n\n    sys.DoStepDynamics(stepsize)"
            ]
        ]
    }
]